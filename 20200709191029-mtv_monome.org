#+title: mtv-monome
* PITFALL: If I need to see the voice_jit or jit_test branches
they are in the old monome/ repo.
* TODO controlling timbre
** TODO many-parameter interface
*** PITFALL Don't worry about changing Zot until experiments are easy.
That is, until I can change parameters with the monome and save settings.
*** TODO BEWARE: Am I incurring tehnical debt?
Ponder continuously: Are there any refactorings I intend to make eventually,
which would be easier earlier?
*** TODO change parameters
**** TODO print stuff
***** TODO print param with each change
***** TODO print all params, ranges in group when selecting group
**** TODO keep ranges as Rationals
**** TODO change timbre of sustained pitches
**** TODO save LED arrangements for each group
*** TODO set the upper and lower bounds of a parameter
*** TODO ? zoom in on a parameter
using multiple rows to set it precisely
*** TODO ? Special keyboard-ish interface for frequency-ish parameters.
*** TODO save timbres
*** TODO store, for each parameter, whether it is linear or logarithmic
*** TODO use tmux or Brick to show multiple GHCIs at once
each for a different kind of display
*** TODO randomize
**** a subset of all parameters
*** TODO ? meta-parameters
*** TODO ? more Zot params
Envelopes.
Vibrato.
Mono effects for poly voices.
** TODO cleanup
*** test the new handlers (ParamGroup and ParamVal)
*** delete Zot_Monome
*** reify magic numbers in Lag.hs
 see comment:
   -- TODO : magic numbers; reify
*** there's something ad-hoc about these passages
**** the "case param of" passages in Monome.Main
**** the ScAction_New passage in Montevideo.Monome.Window.Keyboard
**** the handler in Window.Lag
*** What's up with "on", "amp", "trigger" and "lag"?
 See the header comment here for what they mean:
   ~/mtv/mtv-synth/Montevideo/Synth.hs
* TODO features
** store pitchsets from sustain
*** into variables in GHCI
*** onto a window on the monome
** store timbres
*** into variables in GHCI
*** onto a window on the monome
** transpose {pitchsets, ongoing notes, either keyboard}
** two keyboards, split keyboard
** share pitch LED messages across mtv-lang and mtv-monome
** MORE
*** inc. timbre control for stored chords, other keyboard
*** flash the anchor
*** reset buttons
**** silence all voices
**** redraw entire grid
**** ? restore shift to identity vector
 to remove floating point error
*** sustain to middle of bottom, and duplicate at both top corners
 so that usually something can touch it
*** make pitchsets available on a per-degree basis
*** fixed timbre change across the board
 higher tones are harsher
 rightward tones are (warblier?)
* TODO conceptual major changes to existing code
** record monome state, redraw the whole monome periodically
*** why
Dropped messages to LEDs stop being a (hypothetical) problem.
Shading on both monomes becomes easier.
** don't compute diffs (for SC or monomes) manually
Would require recording both states.
This would be more CPU work, although no more work for SC or the monome.
* TODO clean
** handleSwitch should not know about MVar
 It should instead return an St -> St,
 and limit its IO to SuperCollider,
 and be called with mVarModify (or whatever the word is).

 handleSwitch :: forall app.
                 MVar (St app) -> ((X,Y), Switch) -> IO (Either String ())
** unify the handlers for JI and Keyboard
* TODO bugs
** crashes when a voice is not found
*** TODO Why does it crash?
Even conditional on not finding the note, shouldn't it just print an error and continue?
*** TODO Why is the voice not found?
** probably harmless: threadwait error
*** Whenever I quit, I get this error message.
 <interactive>: threadWait: invalid argument (Bad file descriptor)
*** It's extremely old. Probably harmless?
* TODO conceptual problems
** How to overdub with LED guidance?
*** "manually": store LED patterns on buttons
and push the appropriate button whenever that chord plays.
*** "synchronized": have mtv-lang play the LED pattern in time to the DAW
Start the DAW, listen, start an mtv-lang LED pattern at the appropriate time.
*** "bastard": send messages from the DAW, to (Haskell, to) the monome
Would be awesome but I don't know how,
and encoding LED patterns in the DAW would surely be ugly.
* infrastructure
** add tests
*** TODO test multiple handlers
**** hold 2 notes, press sustain, shift, release one of them
**** hold 2 notes, press sustain, shift, release one of them, release sustain
**** hold a note, shift, press another note, press sustain
**** hold a note, shift, press another note, press sustain, release them
** LedBecause: maybe don't distinguish between keys and sustain
 just use VoiceId
